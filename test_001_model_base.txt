===== RELATÓRIO DO ARQUIVO: test_001_model_base.py =====

===== RESUMO DO TESTE =====
Testes passados: 0
Testes falhados: 1
Erros estruturais (pytest): 0
Warnings: 0

===== TIPOS DE ERROS PYTHON =====
• TypeError: SQLite Date type only accepts Python date objects as input.
• StatementError: (builtins.TypeError) SQLite Date type only accepts Python date objects as input.

===== DETALHES DOS ERROS (TRACEBACKS) =====
Nenhum traceback encontrado.

===== SAÍDA COMPLETA DO PYTEST =====
F                                                                                                                             [100%]
============================================================= FAILURES =============================================================
________________________________________________________ test_criar_usuario ________________________________________________________

self = <sqlalchemy.engine.base.Connection object at 0x00000146A250DE50>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x00000146A24E5BE0>
constructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext'>>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x00000146A25C0980>
parameters = [{'data_nascimento': '1990-01-01', 'email': 'daniel@gmail.com', 'nome': 'Daniel', 'senha_hash': 'abc123'}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x00000146A25BACF0>})
args = (<sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x00000146A25C0980>, [{'data_nascimento': '1990-01-01', 'em...l@gmail.com', 'nome': 'Daniel', 'senha_hash': 'abc123'}], <sqlalchemy.sql.dml.Insert object at 0x00000146A25C0830>, [])
kw = {'cache_hit': <CacheStats.CACHE_MISS: 1>}, yp = None
conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x00000146A25954F0>

    def _execute_context(
        self,
        dialect: Dialect,
        constructor: Callable[..., ExecutionContext],
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
        execution_options: _ExecuteOptions,
        *args: Any,
        **kw: Any,
    ) -> CursorResult[Any]:
        """Create an :class:`.ExecutionContext` and execute, returning
        a :class:`_engine.CursorResult`."""
    
        if execution_options:
            yp = execution_options.get("yield_per", None)
            if yp:
                execution_options = execution_options.union(
                    {"stream_results": True, "max_row_buffer": yp}
                )
        try:
            conn = self._dbapi_connection
            if conn is None:
                conn = self._revalidate_connection()
    
>           context = constructor(
                dialect, self, conn, execution_options, *args, **kw
            )

..\..\miniconda3\Lib\site-packages\sqlalchemy\engine\base.py:1815: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
..\..\miniconda3\Lib\site-packages\sqlalchemy\engine\default.py:1496: in _init_compiled
    flattened_processors[key](compiled_params[key])
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = '1990-01-01'

    def process(value):
        if value is None:
            return None
        elif isinstance(value, datetime_date):
            return format_ % {
                "year": value.year,
                "month": value.month,
                "day": value.day,
            }
        else:
>           raise TypeError(
                "SQLite Date type only accepts Python "
                "date objects as input."
            )
E           TypeError: SQLite Date type only accepts Python date objects as input.

..\..\miniconda3\Lib\site-packages\sqlalchemy\dialects\sqlite\base.py:1287: TypeError

The above exception was the direct cause of the following exception:

session = <sqlalchemy.orm.session.Session object at 0x00000146A24E7380>

    def test_criar_usuario(session):
        from src.models import Usuario
    
        u = Usuario(
            nome = "Daniel",
            email = "daniel@gmail.com",
            senha_hash = "abc123",
            data_nascimento = "1990-01-01"
        )
        session.add(u)
>       session.commit()

formacao_python-developer_dio\SQL_Alchemy\Desafio\projeto\Testes_Fase_1\test_001_model_base.py:11: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
..\..\miniconda3\Lib\site-packages\sqlalchemy\orm\session.py:2030: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
..\..\miniconda3\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
..\..\miniconda3\Lib\site-packages\sqlalchemy\orm\session.py:1311: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
..\..\miniconda3\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
..\..\miniconda3\Lib\site-packages\sqlalchemy\orm\session.py:1286: in _prepare_impl
    self.session.flush()
..\..\miniconda3\Lib\site-packages\sqlalchemy\orm\session.py:4331: in flush
    self._flush(objects)
..\..\miniconda3\Lib\site-packages\sqlalchemy\orm\session.py:4466: in _flush
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\miniconda3\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\miniconda3\Lib\site-packages\sqlalchemy\orm\session.py:4427: in _flush
    flush_context.execute()
..\..\miniconda3\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
..\..\miniconda3\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
..\..\miniconda3\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
..\..\miniconda3\Lib\site-packages\sqlalchemy\orm\persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
..\..\miniconda3\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
..\..\miniconda3\Lib\site-packages\sqlalchemy\sql\elements.py:527: in _execute_on_connection
    return connection._execute_clauseelement(
..\..\miniconda3\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
..\..\miniconda3\Lib\site-packages\sqlalchemy\engine\base.py:1821: in _execute_context
    self._handle_dbapi_exception(
..\..\miniconda3\Lib\site-packages\sqlalchemy\engine\base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
..\..\miniconda3\Lib\site-packages\sqlalchemy\engine\base.py:1815: in _execute_context
    context = constructor(
..\..\miniconda3\Lib\site-packages\sqlalchemy\engine\default.py:1496: in _init_compiled
    flattened_processors[key](compiled_params[key])
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = '1990-01-01'

    def process(value):
        if value is None:
            return None
        elif isinstance(value, datetime_date):
            return format_ % {
                "year": value.year,
                "month": value.month,
                "day": value.day,
            }
        else:
>           raise TypeError(
                "SQLite Date type only accepts Python "
                "date objects as input."
            )
E           sqlalchemy.exc.StatementError: (builtins.TypeError) SQLite Date type only accepts Python date objects as input.
E           [SQL: INSERT INTO usuarios (nome, email, senha_hash, data_nascimento) VALUES (?, ?, ?, ?)]
E           [parameters: [{'senha_hash': 'abc123', 'email': 'daniel@gmail.com', 'nome': 'Daniel', 'data_nascimento': '1990-01-01'}]]

..\..\miniconda3\Lib\site-packages\sqlalchemy\dialects\sqlite\base.py:1287: StatementError
===================================================== short test summary info ======================================================
FAILED formacao_python-developer_dio/SQL_Alchemy/Desafio/projeto/Testes_Fase_1/test_001_model_base.py::test_criar_usuario - sqlalc...
1 failed in 1.74s
